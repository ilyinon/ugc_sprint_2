#### Результаты

##### Вставка записей ( меньше - лучше)
| Вставка записей| MongoDB       | PostgreSQL    |
| ------------- | ------------- | ------------- |
| 1000  | 0,443 секунд  | 6,2 cекунд  |
|  1_000_000  | 44,6 секунд  | 614 секунд  |


##### Время выполенения запросов ( меньше - лучше)
| Время выполнения | MongoDB       | PostgreSQL    |
| ------------- | ------------- | ------------- |
| запрос #1  | 28493мс  | 4413мс  |
| запрос #2  | 15098мс  | 4164мс  |
| запрос #3  | 3682мс  | 3510мс  |
| запрос #4  | 7473мс  | 667мс  |
| запрос #5  | 4524мс  | 3608мс  |


#### Выводы

MongoDB значительно быстрее при вставке данных, как для малого объема (1 000 записей), так и для большого (1 000 000 записей).
Отношение времени вставки между MongoDB и PostgreSQL:
Для 1 000 записей: PostgreSQL медленнее примерно в 14 раз.
Для 1 000 000 записей: PostgreSQL медленнее примерно в 13,77 раз.


##### Причины более быстрой вставки в MongoDB:

Архитектура NoSQL:
MongoDB является документоориентированной базой данных NoSQL и оптимизирована для высокоскоростных операций вставки.
Отсутствие жесткой схемы позволяет MongoDB быстрее записывать данные без необходимости проверки соответствия схеме.
Механизмы записи:
MongoDB использует журнал предзаписи (WAL) и буферизацию, что позволяет быстрее записывать данные в память и диск.
PostgreSQL также использует WAL, но из-за реляционной природы и обеспечения ACID-транзакций вставка данных может быть медленнее.
Надежность и консистентность:
PostgreSQL обеспечивает полную атомарность, консистентность, изоляцию и долговечность (ACID), что требует дополнительных затрат ресурсов при вставке данных.
MongoDB по умолчанию может быть настроен на более слабую консистентность для повышения производительности.




PostgreSQL быстрее выполняет все предоставленные запросы по сравнению с MongoDB.
Отношение времени выполнения между MongoDB и PostgreSQL:

Запрос #1: MongoDB медленнее примерно в 6,46 раза.
Запрос #2: MongoDB медленнее примерно в 3,62 раза.
Запрос #3: MongoDB медленнее примерно в 1,05 раза (практически наравне).
Запрос #4: MongoDB медленнее примерно в 11,2 раза.
Запрос #5: MongoDB медленнее примерно в 1,25 раза.
Причины быстрого выполнения запросов в PostgreSQL:


Оптимизация для сложных запросов:
PostgreSQL — это реляционная СУБД, оптимизированная для сложных запросов и анализа данных.
Использует мощный планировщик и оптимизатор запросов, который эффективно обрабатывает сложные операции.

Индексы и статистика:
PostgreSQL автоматически собирает статистику о данных, что позволяет ему строить оптимальные планы выполнения запросов.
Поддерживает различные типы индексов (B-деревья, GIN, GiST и т.д.), которые ускоряют выборки.

Использование SQL:
SQL предоставляет богатый набор возможностей для агрегации, группировки и сортировки данных.
PostgreSQL реализует многие оптимизации на уровне исполнения SQL-запросов.
Причины более медленного выполнения запросов в MongoDB:


Ограничения Aggregation Framework:
Хотя MongoDB имеет мощный Aggregation Framework, он может быть менее эффективен для некоторых типов запросов по сравнению с реляционными СУБД.
Отсутствие возможности автоматической оптимизации запросов на уровне, сравнимом с PostgreSQL.
Индексирование и план выполнения:
MongoDB требует более тщательной настройки индексов для обеспечения высокой производительности.
В MongoDB может быть сложнее оптимизировать запросы, особенно если данные вложены или структура данных сложна.
Архитектура данных:
Документоориентированная модель может приводить к избыточности данных и увеличению объема выборки.
При больших объемах вложенных данных производительность запросов может снижаться.

##### Общие выводы
MongoDB превосходит PostgreSQL в скорости вставки данных, особенно при массовых вставках. Это делает MongoDB привлекательным для приложений, где важна скорость записи и прием больших объемов данных в реальном времени.

PostgreSQL превосходит MongoDB в скорости выполнения запросов, особенно сложных аналитических запросов с агрегациями, группировкой и сортировкой. Благодаря реляционной модели данных и оптимизированному SQL-движку, PostgreSQL обеспечивает высокую производительность запросов.

Баланс между скоростью вставки и чтения:

Если приложение сильно нагружено операциями записи и требования к мгновенной консистентности невысоки, MongoDB может быть предпочтительнее.

Если приложение требует быстрого выполнения сложных аналитических запросов и транзакционной консистентности, PostgreSQL является лучшим выбором.

##### Заключение
MongoDB предоставляет высокую скорость вставки данных и гибкость структуры документов, что делает ее подходящей для приложений с высокой нагрузкой на запись и гибкими требованиями к схеме данных.

PostgreSQL обеспечивает высокую производительность сложных запросов и транзакционную целостность, что делает ее предпочтительной для приложений, требующих надежности и быстрого доступа к данным.


#### Список использованных запросов:

#####  Mongo
###### 1.
```bash
db.users.aggregate([
    // Разворачиваем поле ratings в пары ключ-значение
    {
        $project: {
            ratings: { $objectToArray: "$ratings" }
        }
    },
    // Разворачиваем массив рейтингов
    { $unwind: "$ratings" },
    // Группируем по item_id и вычисляем средний рейтинг и количество оценок
    {
        $group: {
            _id: "$ratings.k",
            averageRating: { $avg: "$ratings.v" },
            ratingsCount: { $sum: 1 }
        }
    },
    // Сортируем по среднему рейтингу и количеству оценок
    {
        $sort: {
            averageRating: -1,
            ratingsCount: -1
        }
    },
    // Ограничиваем до топ-10
    { $limit: 10 },
    // Переименовываем поля для удобства чтения
    {
        $project: {
            _id: 0,
            itemId: "$_id",
            averageRating: 1,
            ratingsCount: 1
        }
    }
]);
```

###### 2.
```bash
db.users.aggregate([
    // Разворачиваем массив likes
    { $unwind: "$likes" },
    // Группируем по item_id и считаем количество лайков
    {
        $group: {
            _id: "$likes",
            likesCount: { $sum: 1 }
        }
    },
    // Сортируем по количеству лайков
    {
        $sort: {
            likesCount: -1
        }
    },
    // Ограничиваем до топ-10
    { $limit: 10 },
    // Переименовываем поля
    {
        $project: {
            _id: 0,
            itemId: "$_id",
            likesCount: 1
        }
    }
])
```

###### 3.
```bash
db.users.aggregate([
    // Проецируем количество закладок каждого пользователя
    {
        $project: {
            userId: "$_id",
            bookmarksCount: { $size: { $ifNull: ["$bookmarks", []] } }
        }
    },
    // Сортируем по количеству закладок
    {
        $sort: {
            bookmarksCount: -1
        }
    },
    // Ограничиваем до топ-10 пользователей
    { $limit: 10 }
])
```

###### 4.
```bash
var startTime = new Date();
db.users.aggregate([
    // Разворачиваем поле ratings
    {
        $project: {
            ratings: { $objectToArray: "$ratings" }
        }
    },
    { $unwind: "$ratings" },
    // Группируем по значению рейтинга и считаем количество
    {
        $group: {
            _id: "$ratings.v",
            count: { $sum: 1 }
        }
    },
    // Сортируем по значению рейтинга
    {
        $sort: {
            _id: 1
        }
    }
]);
```

###### 5.

```bash
db.users.aggregate([
    // Проецируем количество лайков каждого пользователя
    {
        $project: {
            likesCount: { $size: { $ifNull: ["$likes", []] } }
        }
    },
    // Вычисляем среднее количество лайков
    {
        $group: {
            _id: null,
            averageLikesPerUser: { $avg: "$likesCount" }
        }
    },
    // Выводим результат
    {
        $project: {
            _id: 0,
            averageLikesPerUser: 1
        }
    }
])
```

Posgres
###### 1.

```bash
analyze SELECT
    item_id,
    AVG(rating) AS average_rating,
    COUNT(*) AS ratings_count
FROM
    ratings
GROUP BY
    item_id
ORDER BY
    average_rating DESC,
    ratings_count DESC
LIMIT
    10;
```

###### 2.

```bash
SELECT
    item_id,
    COUNT(*) AS likes_count
FROM
    likes
GROUP BY
    item_id
ORDER BY
    likes_count DESC
LIMIT
    10;

#3
SELECT
    user_id,
    COUNT(*) AS bookmarks_count
FROM
    bookmarks
GROUP BY
    user_id
ORDER BY
    bookmarks_count DESC
LIMIT
    10;
```

###### 4.

```bash
SELECT
    rating,
    COUNT(*) AS count
FROM
    ratings
GROUP BY
    rating
ORDER BY
    rating;
```

###### 5.
```bash
SELECT
    AVG(user_likes.likes_count) AS average_likes_per_user
FROM (
    SELECT
        user_id,
        COUNT(*) AS likes_count
    FROM
        likes
    GROUP BY
        user_id
) user_likes;
```
